---
sidebar_position: 2
custom_edit_url: https://github.com/bcnmy/docs/blob/master/docs/Account/integration.mdx
---

# Integration

Smart Accounts are created deterministically using the [CREATE2](https://docs.openzeppelin.com/cli/2.7/deploying-with-create2) opcode, meaning the smart account address can be identified even before it is deployed. It will also maintain the same address across different chains. 

To integrate `Biconomy Smart Account`, you'll need the [bundler url](/dashboard#bundler-url). If you also want to use the paymaster, you'll need [Paymaster api key](/paymaster).

## Installation

First, install the following packages for initializing the Smart Account.

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs>
<TabItem value="js" label="npm">

```bash

npm install @biconomy/account

```

</TabItem>
<TabItem value="py" label="yarn">

```bash

yarn add @biconomy/account

```

</TabItem>
<TabItem value="java" label="pnpm">

```bash

pnpm add @biconomy/account

```

</TabItem>
</Tabs>

## Integration

Specify PRIVATE_KEY, BUNDLER_URL and RPC_URL (for ethers) to create a smart account. 

<Tabs>
<TabItem value="js" label="Viem">

```typescript
  import { Hex, createWalletClient, http } from "viem";
  import { privateKeyToAccount } from "viem/accounts";
  import { polygonMumbai } from "viem/chains";
  import { createSmartAccountClient } from "@biconomy/account";

  // ----- 1. Generate EOA from private key
  const account = privateKeyToAccount("PRIVATE_KEY"); 
  const client = createWalletClient({
    account,
    chain: polygonMumbai,
    transport: http(),
  });
  const eoa = client.account.address;
  console.log(`EOA address: ${eoa}`);

  // ------ 2. Create biconomy smart account instance
  const smartAccount = await createSmartAccountClient({
    signer: client,
    bundlerUrl: "BUNDLER_URL",
    biconomyPaymasterApiKey: "", // optional
  });
  const smartAccountAddress = await smartAccount.getAccountAddress();
  console.log("Smart Account Address", smartAccountAddress);

```

</TabItem>
<TabItem value="py" label="Ethers">

```typescript
  import { ethers } from "ethers";	
  import { createSmartAccountClient } from "@biconomy/account";

  let provider = new ethers.providers.JsonRpcProvider("RPC_URL");
  let signer = new ethers.Wallet("PRIVATE_KEY", provider);

  const biconomySmartAccountConfig = {
    signer: signer,
    bundlerUrl: "BUNDLER_URL",
    biconomyPaymasterApiKey: "", // optional
  };

  const smartAccount = await createSmartAccountClient(
    biconomySmartAccountConfig
  );

  const smartAccountAddress = await smartAccount.getAccountAddress();
  console.log("Smart Account Address", smartAccountAddress);
```

</TabItem>

<TabItem value="Alchemy" label="Alchemy">

```typescript
  import { ethers } from "ethers";	
  import { polygonMumbai } from "viem/chains";
  import { createSmartAccountClient } from "@biconomy/account";
  import { WalletClientSigner } from "@alchemy/aa-core";

  const account = privateKeyToAccount("PRIVATE_KEY");
  const client = createWalletClient({
    account,
    chain: polygonMumbai,
    transport: http(),
  });
  const alchemySigner = new WalletClientSigner(client, "json-rpc"); 
  const smartAccount = await createSmartAccountClient({
    signer: alchemySigner,
    bundlerUrl: config.bundlerUrl,
    biconomyPaymasterApiKey: config.biconomyPaymasterApiKey,
  });
  const scwAddress = await smartAccount.getAccountAddress();
  console.log("SCW Address", scwAddress);
```

</TabItem>

</Tabs>

In this doc, following values are used by default:
- ECDSA Validation Module, other validation [modules](/modules) can be enabled based on the specific use case.
- The default entry point [address](contracts.md) is used for the chainId.
- An index with a value 0, but you can also specify a custom index value in the configuration to generate multiple smart accounts with the same signer.

CREATE2 allows us to enable flows where users could even send funds to an undeployed wallet, which could then be used to pay for the gas for deployment.
Smart account will be deployed with the first UserOp execution. 

